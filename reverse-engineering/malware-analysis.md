# Malware analysis

The goal of malware analysis and reverse engineering is to determine of a sample of code is malicious or not.

If the sample is determined to be safe the analysis stop here, the same goes if the sample have already been analysised, there probably exist a report of IOC or sigma rules set which will allow you to detect the sample.

![](https://lh3.googleusercontent.com/RsYYHZwVCyP9qFPknlJOc9H_wERPuLoBevXenqcUrV0cIEb6zVkpIBjhpP1Fy-dMvsY2X4qDOxF_JVZD_J4s7NyCzGRbQ4LDyXfIZh1g5L2a_32iwZR4MuobOZOy1A2cC7gpUYWo8kNtR306kA)

# Static 

Analysis of the malware without executing it, by analyzing file attributes such as hashed, code-signed, and embedded strings, if from these elements can not determine if the file is malicious or not, the next step is to disassemble the binary for in-depth analysis.

Because of the uniqueness of the file hash, it can be uploaded to a malware database to see if others have seen the sample before.

Code signing will indicate the author of the code, which allow one to determine if the bin is from a known source, and if it has been modified since last signed. 
This allows the analysis to quickly determine if the sample is begin or not simple by looking at the author of the file, looking of unsigned code or claims to be from a valid source

Strings - Allow one to extract strings from a complied binary, which can provide insight in to the capabilities of the bin, it will look for ASCII strings within bin file.
Some information that can be gain from looking at strings is things such as : messages, method or function names, configuratiaon files and urls.

## Disassembling (code-analysis)

Binaries are written in programming language that is compiled into binary code that are interpreted at runtime into commands or code that the system understand.
when getting started with code-analysis a good starting point:
What API calls it makes
What are the arguments that are passed into these API calls
And if are any logic flow based upon the result of the calls

### Identifying interresting areas

Some techniques that have been developed as I reverse engineered software.

#### Utility functions

If there isn't an test after an call it most likely not of interest as the function called not does have an return value and most likely an utility function.

#### Decryption function

If the same function is called multiple times there high possibility it a decryption function

### Syscalls

Instead of using ntdll.dll to make syscalls, they are instead directly called by using the syscall ID of the call we want to execute.

# Dynamic
    
Execute the malware in a controlled environment for analysis, and monitoring it activity.

## Environment
    
Because we are working with live malware that can take control of the computer and spread it self to othersystem.
It is important when analysis the malware is done inside a contained environmen. One way of doing this is using a virtual environment, using software such as VMware or VirtualBox.
When it comes to image to use I find https://remnux.org/ to be very usefull as it comes feature rich is malware analysis tools.

Because most malware is aimed at windows, it an good idea to have two virtual machines and Windows box where you can executed malware in and monitor it behaviour and an Linux machine where you do static analysis.

### Network

Many malware will try to perform an internet check to see if they are on a connected host, if they are unable to reach out they will self-destruct to stop malware analysis to look into the malware.

One way to set up an fake network is by either using [Fakenet-ng](https://github.com/mandiant/flare-fakenet-ng) or [INetSim](https://www.inetsim.org/). Both these solution will try to simulate an network for the malware to connect up to.

The way I set it up is by having all my windows network forwared to the Linux box which is running INetSim for simulate the network and Wireshark for analysis the packets.


# Unpackage malware

Unpack malware using memory hardware breakpoints
The first time the program touch the stack set an hardware breakpoint there everytime it is accessed
    
XDbg ⇒ Right click on the memory ⇒ breakpoint ⇒ hardware access ⇒ Dword (32) Qwork (64) because it save a memory address

Then allow the program to run and it should stop when it touches the memory, each time it stop in the analyzed program check the for string references if there is no interesting continue the program checking everytime it stop for string references

XDbg 
- Plugins ⇒ OllyDebugEx ⇒ Get EIP as OEP ⇒ Fix Virutal offset ⇒ Dump Fix imports ⇒ scylla ⇒  IAT autosearch ⇒ Get imports ⇒ Fix Dump


# Analysis of scripts

Script are often obfuscated to make it more difficult to analysis the purpose of the script, the best to handle this is taking it slow and decode the script line by line.
Another solution is doing it dynamic and running the script with monitoring tools attached.

# Forensic Techniques

**Feature extraction**

The goal is feature extraction is to identify unique static metadata from files. tools such as Strings is very useful to get metadata about the file. Malware comes in many different formats.

**Office file**

Malware office files frequently comes in form of visual basic macro or excel 4.0 macro. extracting macros from office files with oledump to do static analyze without having to run the malware. Fequently the marco is obfuscatated to make it hard to understand, using deobfuscation tools can help with this.

**Behavior extraction**

Behavior extraction is the method of executing the malware and analyzing how what it behavior it doing inside a sandbox.

#### Forensic procedures

**Executable Behavior extraction**

WIth the executable in hand, isolating it in a sandbox and executing it there and analyzing the log files of the system is a quick way to get an understanding of the procedure of the malware and what it does and in what order. An good example of this is doc files with embedded macros, taking it to a windows sandbox and executing it there to analyze what it does using Windows Sysmon

## **Obfuscation**

### **Ghost writing**

Ghost Writing is a way of Obfuscating the binary / assembly code in such a way that the signature no longer exists due to malware code obfuscation and no functionality of the malware is lost . The Idea here is to add random Assembly instructions to the disassembly of the executable and maitaining the functionality of the malware at the sametime. This is also called ghostwriting for antivirus An common way to do this is using Metasploit msfvenom to output the malware in raw binary. use ruby libery metasm (gem install metasm) to convert the binary to assembly code. edit the assembly to scamble the signature (common way is before a point get xor with it self, add some random code to the pointer ) convert the assembly code to executable and you have a scambled malware.
